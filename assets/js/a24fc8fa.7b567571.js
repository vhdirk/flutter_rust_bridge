"use strict";(self.webpackChunkflutter_rust_bridge=self.webpackChunkflutter_rust_bridge||[]).push([[7239],{3905:(e,a,t)=>{t.d(a,{Zo:()=>l,kt:()=>m});var n=t(67294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function u(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=n.createContext({}),p=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):u(u({},a),e)),t},l=function(e){var a=p(e.components);return n.createElement(s.Provider,{value:a},e.children)},d={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},c=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),c=p(t),m=r,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||i;return t?n.createElement(h,u(u({ref:a},l),{},{components:t})):n.createElement(h,u({ref:a},l))}));function m(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=t.length,u=new Array(i);u[0]=c;var o={};for(var s in a)hasOwnProperty.call(a,s)&&(o[s]=a[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,u[1]=o;for(var p=2;p<i;p++)u[p]=t[p];return n.createElement.apply(null,u)}return n.createElement.apply(null,t)}c.displayName="MDXCreateElement"},41207:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>p,contentTitle:()=>o,default:()=>c,frontMatter:()=>u,metadata:()=>s,toc:()=>l});var n=t(87462),r=(t(67294),t(3905)),i=t(44783);const u={},o="Rust Opaque",s={unversionedId:"guides/contributing/submodules/rust-opaque",id:"guides/contributing/submodules/rust-opaque",title:"Rust Opaque",description:"Design",source:"@site/docs/guides/contributing/submodules/rust-opaque.md",sourceDirName:"guides/contributing/submodules",slug:"/guides/contributing/submodules/rust-opaque",permalink:"/flutter_rust_bridge/guides/contributing/submodules/rust-opaque",draft:!1,editUrl:"https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/website/docs/guides/contributing/submodules/rust-opaque.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"SSE Codec",permalink:"/flutter_rust_bridge/guides/contributing/submodules/sse-codec"},next:{title:"Dart Opaque",permalink:"/flutter_rust_bridge/guides/contributing/submodules/dart-opaque"}},p={},l=[{value:"Design",id:"design",level:2},{value:"Safety concern",id:"safety-concern",level:2},{value:"Transferring between Rust and Dart",id:"transferring-between-rust-and-dart",level:2},{value:"Details of the components",id:"details-of-the-components",level:2},{value:"<code>Droppable</code>",id:"droppable",level:3},{value:"<code>RustArc</code>",id:"rustarc",level:3},{value:"<code>RustOpaque</code>",id:"rustopaque",level:3},{value:"V1 documentations",id:"v1-documentations",level:2},{value:"Restrictions",id:"restrictions",level:3},{value:"Ownership and GC",id:"ownership-and-gc",level:3},{value:"Rust opaque type like function args",id:"rust-opaque-type-like-function-args",level:3},{value:"Example",id:"example",level:3},{value:"Case 1: Simple call.",id:"case-1-simple-call",level:4},{value:"Case 2: Call after dispose.",id:"case-2-call-after-dispose",level:4},{value:"Case 3: Dispose before complete.",id:"case-3-dispose-before-complete",level:4},{value:"Case 4: Multi call.",id:"case-4-multi-call",level:4},{value:"Case 5: Double call with dispose before complete.",id:"case-5-double-call-with-dispose-before-complete",level:4},{value:"Case 6: Dispose was not called (native).",id:"case-6-dispose-was-not-called-native",level:4},{value:"Case 7: Dispose was not called (web).",id:"case-7-dispose-was-not-called-web",level:4},{value:"Case 8: Unwrap.",id:"case-8-unwrap",level:4}],d={toc:l};function c(e){let{components:a,...t}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"rust-opaque"},"Rust Opaque"),(0,r.kt)("h2",{id:"design"},"Design"),(0,r.kt)("p",null,"We try our best to achieve the following:"),(0,r.kt)("admonition",{title:"goal",type:"tip"},(0,r.kt)(i.ZP,{mdxType:"Goal"})),(0,r.kt)("h2",{id:"safety-concern"},"Safety concern"),(0,r.kt)("p",null,"When looking at the components below, one critical question is: Is the implementation safe and sound?\nWith the following three components, in my humble opinion, the question is roughly splitted into:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Droppable"),': Does it ensure the "release the resource once and exactly once"?'),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"RustArc"),": Does it ensure the semantics of standard ",(0,r.kt)("inlineCode",{parentName:"li"},"std::sync::Arc"),"?\nE.g. after ",(0,r.kt)("inlineCode",{parentName:"li"},"intoRaw"),' is called, are we guarantee the pointer is "forgotten"?'),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"RustOpaque"),": Together with the Rust side, is the ",(0,r.kt)("inlineCode",{parentName:"li"},"Arc::into_raw")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Arc::from_raw")," paired? (One ",(0,r.kt)("inlineCode",{parentName:"li"},"into_raw")," for one ",(0,r.kt)("inlineCode",{parentName:"li"},"from_raw"),")")),(0,r.kt)("p",null,"Since each component is quite tiny, it is not very hard to check it.\nFeel free to create an issue if you find any problems!"),(0,r.kt)("h2",{id:"transferring-between-rust-and-dart"},"Transferring between Rust and Dart"),(0,r.kt)("p",null,"With the three-components abstractions below, this can be explained within a sentence:\nTo transfer a ",(0,r.kt)("inlineCode",{parentName:"p"},"RustOpaque")," (indeed an ",(0,r.kt)("inlineCode",{parentName:"p"},"Arc"),"),\ndo ",(0,r.kt)("inlineCode",{parentName:"p"},"std::sync::Arc::into_raw")," on one side,\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"std::sync::Arc::from_raw")," on the other side.\n(Replace ",(0,r.kt)("inlineCode",{parentName:"p"},"Arc")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"RustArc")," when proper)."),(0,r.kt)("h2",{id:"details-of-the-components"},"Details of the components"),(0,r.kt)("p",null,"(The text below are mainly copied from the code comments.)"),(0,r.kt)("h3",{id:"droppable"},(0,r.kt)("inlineCode",{parentName:"h3"},"Droppable")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"class Droppable {\n  PlatformPointer? _ptr;\n  void dispose() { ... }\n}\n")),(0,r.kt)("p",null,"Encapsulates the ",(0,r.kt)("inlineCode",{parentName:"p"},"internalResource")," release logic."),(0,r.kt)("p",null,"In Rust, it is simple to release some resource: Just implement ",(0,r.kt)("inlineCode",{parentName:"p"},"Drop")," trait.\nHowever, there are two possible chances to release resource in Dart:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"When the object is garbage collected, the Dart finalizer will call a callback you choose."),(0,r.kt)("li",{parentName:"ol"},"When the user explicitly calls ",(0,r.kt)("inlineCode",{parentName:"li"},"dispose()")," function, you can do releasing job.")),(0,r.kt)("p",null,"But we want to release the ",(0,r.kt)("inlineCode",{parentName:"p"},"internalResource")," ",(0,r.kt)("em",{parentName:"p"},"once and exactly once"),".\nThat's what this class does."),(0,r.kt)("h3",{id:"rustarc"},(0,r.kt)("inlineCode",{parentName:"h3"},"RustArc")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"class RustArc extends Droppable {\n  RustArc clone() { ... }\n  RustArc.fromRaw({int ptr}) { ... }\n  PlatformPointer intoRaw() { ... }\n}\n")),(0,r.kt)("p",null,"The Rust ",(0,r.kt)("inlineCode",{parentName:"p"},"std::sync::Arc")," on the Dart side."),(0,r.kt)("p",null,"It uses ",(0,r.kt)("inlineCode",{parentName:"p"},"Droppable")," to ensure the Arc's destructor is correctly called exactly once."),(0,r.kt)("h3",{id:"rustopaque"},(0,r.kt)("inlineCode",{parentName:"h3"},"RustOpaque")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"abstract class RustOpaque {\n  final RustArc _arc;\n  RustOpaque.decode(raw) { ... }\n  int encode() { ... }\n}\n")),(0,r.kt)("p",null,"Finally, the object we are interested in."),(0,r.kt)("p",null,"It uses ",(0,r.kt)("inlineCode",{parentName:"p"},"RustArc")," to hold the actual data."),(0,r.kt)("h2",{id:"v1-documentations"},"V1 documentations"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"This section was written for V1, so it may be slightly outdated for V2.")),(0,r.kt)("h3",{id:"restrictions"},"Restrictions"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"RustOpaque type")," can be created from any Rust structure.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"flutter_rust_bridge")," async dart api requires the Rust type to be ",(0,r.kt)("inlineCode",{parentName:"p"},"Send")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Sync"),", due to the possible sharing of ",(0,r.kt)("inlineCode",{parentName:"p"},"RustOpaque type")," by multiple ",(0,r.kt)("inlineCode",{parentName:"p"},"flutter_rust_bridge")," executor threads."),(0,r.kt)("h3",{id:"ownership-and-gc"},"Ownership and GC"),(0,r.kt)("p",null,"From the moment an opaque type is passed to Dart, it has full ownership of it.\nDart implements a finalizer for opaque types, but the memory usage of opaque types is not monitored by Dart and can accumulate, so in order to prevent memory leaks, opaque pointers must be ",(0,r.kt)("inlineCode",{parentName:"p"},"dispose"),"d."),(0,r.kt)("h3",{id:"rust-opaque-type-like-function-args"},"Rust opaque type like function args"),(0,r.kt)("p",null,"When calling a function with an opaque type argument, the Dart thread safely shares ownership of the opaque type with Rust. This is safe because ",(0,r.kt)("inlineCode",{parentName:"p"},"RustOpaque<T>")," requires that T be ",(0,r.kt)("inlineCode",{parentName:"p"},"Send")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Sync"),", furthermore Rust's ",(0,r.kt)("inlineCode",{parentName:"p"},"RustOpaque<T>")," hand out immutable references through ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref")," or get an internal property if only Rust owns the opaque type. If dispose is called on the Dart side before the function call completes, Rust takes full ownership."),(0,r.kt)("h3",{id:"example"},"Example"),(0,r.kt)("h4",{id:"case-1-simple-call"},"Case 1: Simple call."),(0,r.kt)("p",null,"Rust ",(0,r.kt)("inlineCode",{parentName:"p"},"api.rs"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub use crate::data::HideData; // `pub` for bridge_generated.rs\n\npub fn create_opaque() -> RustOpaque<HideData> {\n    // [`HideData`] has private fields.\n    RustOpaque::new(HideData::new())\n}\n\npub fn run_opaque(opaque: RustOpaque<HideData>) -> String {\n    // RustOpaque impl Deref trait.\n    opaque.hide_data()\n}\n")),(0,r.kt)("p",null,"Dart: (test:'Simple call' frb_example/pure_dart/dart/lib/main.dart)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// (Arc counter = 2) for the duration of the function \n// and after (Arc counter = 1).\n// \n// Dart and Rust share the opaque type.\nString hideData = await api.runOpaque(opaque);\n\n// (Arc counter = 0) opaque type is dropped (deallocated).\nopaque.dispose();\n")),(0,r.kt)("h4",{id:"case-2-call-after-dispose"},"Case 2: Call after dispose."),(0,r.kt)("p",null,"Rust ",(0,r.kt)("inlineCode",{parentName:"p"},"api.rs"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub use crate::data::HideData; // `pub` for bridge_generated.rs\n\npub fn create_opaque() -> RustOpaque<HideData> {\n    // [`HideData`] has private fields.\n    RustOpaque::new(HideData::new())\n}\n\npub fn run_opaque(opaque: RustOpaque<HideData>) -> String {\n    // RustOpaque impl Deref trait.\n    opaque.hide_data()\n}\n")),(0,r.kt)("p",null,"Dart: (test:'Call after dispose' frb_example/pure_dart/dart/lib/main.dart)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// (Arc counter = 0) opaque type dropped (deallocated)\nopaque.dispose();\n\n// (Arc counter = 0) Dart throws StateError('Use after dispose.')\ntry {\n    await api.runOpaque(opaque: opaque);\n} on StateError catch (e) {\n    expect(e.toString(), 'Bad state: Use after dispose.');\n}\n")),(0,r.kt)("h4",{id:"case-3-dispose-before-complete"},"Case 3: Dispose before complete."),(0,r.kt)("p",null,"Rust ",(0,r.kt)("inlineCode",{parentName:"p"},"api.rs"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub use crate::data::HideData; // `pub` for bridge_generated.rs\n\npub fn create_opaque() -> RustOpaque<HideData> {\n    // [`HideData`] has private fields.\n    RustOpaque::new(HideData::new())\n}\n\npub fn run_opaque(opaque: RustOpaque<HideData>) -> String {\n    // RustOpaque impl Deref trait.\n    opaque.hide_data()\n}\n\npub fn run_opaque_with_delay(opaque: RustOpaque<HideData>) -> String {\n    sleep(Duration::from_millis(1000));\n    opaque.hide_data()\n}\n")),(0,r.kt)("p",null,"Dart:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// (Arc counter = 2) increases immediately. \n// Dart and Rust share the opaque type.\n// Safely because opaque type has `Send` `Sync` Rust trait.\nvar unawait_task = api.runOpaqueWithDelay(opaque: opaque);\n\n// (Arc counter = 1) Rust has full ownership.\n// Dart stops owning the opaque type. \n// Trying to use an opaque type will throw StateError('Use after dispose.')\nopaque.dispose();\n\n// Successfully completed.\n//\n// Rust:\n// `executes run_opaque_with_delay.`\n// after complete (Arc counter = 0) \n// opaque type is dropped (deallocated)\nawait unawait_task;\n")),(0,r.kt)("h4",{id:"case-4-multi-call"},"Case 4: Multi call."),(0,r.kt)("p",null,"Rust ",(0,r.kt)("inlineCode",{parentName:"p"},"api.rs"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub use crate::data::HideData; // `pub` for bridge_generated.rs\n\npub fn create_opaque() -> RustOpaque<HideData> {\n    // [`HideData`] has private fields.\n    RustOpaque::new(HideData::new())\n}\n\npub fn run_opaque(opaque: RustOpaque<HideData>) -> String {\n    // RustOpaque impl Deref trait.\n    opaque.hide_data()\n}\n")),(0,r.kt)("p",null,"Dart: (test:'Double Call' frb_example/pure_dart/dart/lib/main.dart)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// (Arc counter = 2) increases immediately.\n// (Arc counter = 1) after complete\nString hideData1 = await api.runOpaque(opaque: opaque);\n\n// (Arc counter = 2) increases immediately.\n// (Arc counter = 1) after complete\nString hideData2 = await api.runOpaque(opaque: opaque);\n\n// (Arc counter = 0) opaque type is dropped (deallocated)\nopaque.dispose();\n")),(0,r.kt)("h4",{id:"case-5-double-call-with-dispose-before-complete"},"Case 5: Double call with dispose before complete."),(0,r.kt)("p",null,"Rust ",(0,r.kt)("inlineCode",{parentName:"p"},"api.rs"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub use crate::data::HideData; // `pub` for bridge_generated.rs\n\npub fn create_opaque() -> RustOpaque<HideData> {\n    // [`HideData`] has private fields.\n    RustOpaque::new(HideData::new())\n}\n\npub fn run_opaque(opaque: RustOpaque<HideData>) -> String {\n    // RustOpaque impl Deref trait.\n    opaque.hide_data()\n}\n")),(0,r.kt)("p",null,"Dart:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// (Arc counter = 2) increases immediately. \nvar unawait_task1 = api.runOpaque(opaque); *1\n\n// (Arc counter = 3) increases immediately. \nvar unawait_task2 = api.runOpaque(opaque); *2\n\n// (Arc counter = 2) Rust has full ownership\nopaque.dispose();\n\n// (*1 is complete) (Arc counter = 1)\n//\n// Rust:\n//\n//`executes rust_call_example and counter decreases.`\n\n// (*2 is complete) (Arc counter = 0) \n// opaque type is dropped (deallocated)\n//\n// Rust:\n//\n//`executes rust_call_example and drop opaque type.`\n")),(0,r.kt)("h4",{id:"case-6-dispose-was-not-called-native"},"Case 6: Dispose was not called (native)."),(0,r.kt)("p",null,"Rust ",(0,r.kt)("inlineCode",{parentName:"p"},"api.rs"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub use crate::data::HideData; // `pub` for bridge_generated.rs\n\npub fn create_opaque() -> RustOpaque<HideData> {\n    // [`HideData`] has private fields.\n    RustOpaque::new(HideData::new())\n}\n\npub fn run_opaque(opaque: RustOpaque<HideData>) -> String {\n    // RustOpaque impl Deref trait.\n    opaque.hide_data()\n}\n")),(0,r.kt)("p",null,"Dart:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// (Arc counter = 2) increases immediately. \nString hideData = await api.runOpaque(opaque);\n\n// (Arc counter = 1)\n//\n// Rust:\n//\n// `executes rust_call_example and counter decreases.`\n\n// memory of opaque types is not monitoring by dart and can accumulate.\n// (Arc counter = 0) \n// opaque type is dropped (deallocated)\n// \n// Dart:\n//\n// `the finalizer is guaranteed to be called before the program terminates.`\n")),(0,r.kt)("h4",{id:"case-7-dispose-was-not-called-web"},"Case 7: Dispose was not called (web)."),(0,r.kt)("p",null,"Rust ",(0,r.kt)("inlineCode",{parentName:"p"},"api.rs"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub use crate::data::HideData; // `pub` for bridge_generated.rs\n\npub fn create_opaque() -> RustOpaque<HideData> {\n    // [`HideData`] has private fields.\n    RustOpaque::new(HideData::new())\n}\n\npub fn run_opaque(opaque: RustOpaque<HideData>) -> String {\n    // RustOpaque impl Deref trait.\n    opaque.hide_data()\n}\n")),(0,r.kt)("p",null,"Dart:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque(); \n\n// (Arc counter = 2) increases immediately. \nString hideData = await api.rustOpaque(opaque);\n\n// (Arc counter = 1)\n//\n// Rust:\n//\n//`executes rust_call_example and counter decreases.`\n\n// memory of opaque types is not monitoring by Dart and can accumulate.\n// (Arc count can be 0 or 1) don't count on automatic clearing.\n//\n// Dart:\n//\n//`the finalizer is NOT guaranteed to be called before the program terminates.`\n")),(0,r.kt)("h4",{id:"case-8-unwrap"},"Case 8: Unwrap."),(0,r.kt)("p",null,"Rust ",(0,r.kt)("inlineCode",{parentName:"p"},"api.rs"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'pub use crate::data::HideData; // `pub` for bridge_generated.rs\n\npub fn unwrap_rust_opaque(opaque: Opaque<HideData>) -> Result<String> {\n    let res: Result<HideData, Opaque<HideData>> = opaque.try_unwrap();\n    let data: HideData = res.map_err(|_| anyhow::anyhow!("opaque type is shared"))?;\n    Ok(data.hide_data())\n}\n\n')),(0,r.kt)("p",null,"Dart:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// When passed as an argument, dart will relinquish ownership.\nopaque.move = true;\n\n// (Arc counter = 1) Rust has full ownership.\n// On the Rust side, the Arc unwrap safely \n// as the Rust has full ownership of the opaque type. \n// Memory is cleared in the usual way Rust.\nawait api.unwrapRustOpaque(opaque: data);\n")))}c.isMDXComponent=!0},44783:(e,a,t)=>{t.d(a,{ZP:()=>u});var n=t(87462),r=(t(67294),t(3905));const i={toc:[]};function u(e){let{components:a,...t}=e;return(0,r.kt)("wrapper",(0,n.Z)({},i,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'The unsafe code should be carefully encapsulated, as minimal as possible,\nand have a clearly defined and easily checkable semantics.\nEach component should be focused on one clear thing only ("single-responsibility rule").'),(0,r.kt)("li",{parentName:"ul"},"No matter how users use or mis-use it, it should be safe (e.g. no undefined behavior).\nSafety and soundness is critical.")))}u.isMDXComponent=!0}}]);