"use strict";(self.webpackChunkflutter_rust_bridge=self.webpackChunkflutter_rust_bridge||[]).push([[2023],{3905:(e,t,r)=>{r.d(t,{Zo:()=>l,kt:()=>p});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function u(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},l=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},y=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,l=u(e,["components","mdxType","originalType","parentName"]),y=c(r),p=o,f=y["".concat(s,".").concat(p)]||y[p]||d[p]||a;return r?n.createElement(f,i(i({ref:t},l),{},{components:r})):n.createElement(f,i({ref:t},l))}));function p(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=y;var u={};for(var s in t)hasOwnProperty.call(t,s)&&(u[s]=t[s]);u.originalType=e,u.mdxType="string"==typeof e?e:o,i[1]=u;for(var c=2;c<a;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}y.displayName="MDXCreateElement"},1567:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>u,toc:()=>c});var n=r(87462),o=(r(67294),r(3905));const a={},i="Asynchronous Dart",u={unversionedId:"guides/concurrency/async-dart",id:"guides/concurrency/async-dart",title:"Asynchronous Dart",description:"This library generates functions that are asynchronous in Dart by default. So you will see fn f(..) -> String becomes Future f(..) with that interesting Future.",source:"@site/docs/guides/concurrency/async-dart.md",sourceDirName:"guides/concurrency",slug:"/guides/concurrency/async-dart",permalink:"/flutter_rust_bridge/guides/concurrency/async-dart",draft:!1,editUrl:"https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/website/docs/guides/concurrency/async-dart.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Synchronous Dart",permalink:"/flutter_rust_bridge/guides/concurrency/sync-dart"},next:{title:"Customization",permalink:"/flutter_rust_bridge/guides/custom/"}},s={},c=[],l={toc:c};function d(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"asynchronous-dart"},"Asynchronous Dart"),(0,o.kt)("p",null,"This library generates functions that are ",(0,o.kt)("em",{parentName:"p"},"asynchronous")," in Dart by default. So you will see ",(0,o.kt)("inlineCode",{parentName:"p"},"fn f(..) -> String")," becomes ",(0,o.kt)("inlineCode",{parentName:"p"},"Future<String> f(..)")," with that interesting ",(0,o.kt)("inlineCode",{parentName:"p"},"Future"),"."),(0,o.kt)("p",null,"Why? Flutter UI is single-threaded. If you use the intuitive synchronous approach, just like what you will (have to) do with plain-old Flutter bindings, your UI will be ",(0,o.kt)("em",{parentName:"p"},"stuck")," as long as your Rust code is executing. If your Rust code run for 100ms for a heavy computation, your UI will fully freeze for 100ms and the users will not be happy."),(0,o.kt)("p",null,"On the other hand, with the generated asynchronous bindings in Dart, you can simply call functions directly in main isolate (thread) of Dart/Flutter, and Rust code will not block the Flutter UI."),(0,o.kt)("p",null,"Indeed async and ",(0,o.kt)("inlineCode",{parentName:"p"},"Future"),"s is almost everywhere in Flutter/Dart, and it has very good built-in support. So no worries about it ;)"),(0,o.kt)("p",null,"Remark: A common mistake is to call Rust code in ",(0,o.kt)("em",{parentName:"p"},"another"),' Dart isolate (i.e. "thread") instead of the main isolate. That is completely not needed, and will only make your life harder. As is described above, even if your Rust code computes for 100ms, the async call will only take, say, 0.1ms, and will not block your UI.'))}d.isMDXComponent=!0}}]);